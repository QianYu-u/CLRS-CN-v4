# 1 算法在计算中的作用

什么是算法？为什么算法值得研究？算法的作用是什么？
相对于计算机中使用的其他技术，算法的作用如何？本章将回答这些问题。

---

## 1.1 算法

非正式地解释，**算法**是任何明确定义的计算过程，它接受某个值或一组值作为**输入**，并在有限的时间内产生某个值或一组值作为**输出**。因此，算法是一系列计算步骤，将输入转换为输出。

你也可以将算法视为解决明确指定的**计算问题**的工具。问题的描述通常用一般性术语规定了所需的输入/输出关系，这些问题实例的规模通常是任意大的。算法描述了一个具体的计算过程，用于实现所有问题实例的输入/输出关系。

例如，假设你需要将一个数字序列排序为单调递增的顺序。这个问题在实践中经常出现，为介绍许多标准设计技术和分析工具提供了丰富的素材。以下是我们正式定义**排序问题**的方式：

**输入：** 一个由 *n* 个数组成的序列 &lang;*a*₁ , *a*₂ , ... , *aₙ*&rang;。

**输出：** 输入序列的一个排列 &lang;*a*'₁ , *a*'₂ , ... , *a'ₙ*&rang;，满足 *a*'₁ &le; *a*'₂ &le; ... &le; *a'ₙ*。

因此，给定输入序列 &lang;31; 41; 59; 26; 41; 58&rang;，正确的排序算法返回的输出序列为 &lang;26; 31; 41; 41; 58; 59&rang;。这样的输入序列被称为排序问题的一个**实例**(由抽象转变为具象)。一般来说，**问题的一个实例**^1^是由计算问题解决方案所需的输入组成（满足问题陈述中施加的任何约束）。

因为许多程序将排序作为中间步骤，排序是计算机科学中的一项基本操作。因此，你可以使用大量好的排序算法。对于给定的应用程序，哪种算法最佳取决于-- 除了其他因素外 -- 要排序的项目数量、项目已排序的程度、对项目值的可能限制、计算机的体系结构，以及要使用的存储设备类型：主存储器、磁盘，甚至陈旧物品——磁带。

若针对计算问题中的任一问题输入，算法均能在有限时间内终止运算并输出该实例的**正确解**，则该算法具有正确性。正确的算法能够**解决**给定的计算问题。而不正确的算法可能在部分输入实例下**无法终止**，或在终止时给出错误结果。与直觉相悖的是，若能够控制其错误率，不完全正确的算法仍可能具有实用价值。例如第三十一章讨论大素数判定算法时，我们将看到具有可控错误率的算法实例。但通常情况下，我们仅关注具有正确性的算法。

算法可以用英文、计算机程序，甚至硬件设计来描述。唯一的要求是该描述必须提供要遵循的计算过程的精确描述。

### 什么样的问题由算法来解决？

排序绝不是唯一被开发出算法的计算问题。（当你看到这本书的厚度时，你可能已经猜到了这一点。）算法的实际应用无处不在，包括以下示例：

- 人类基因组计划在实现以下目标方面取得了重大进展：确定人类 DNA 中约 30,000 个基因；确定构成人类 DNA 的约 30 亿个化学碱基对的序列；将这些信息存储在数据库中；以及开发用于数据分析的工具。每个步骤都需要复杂的算法。尽管所涉及的各种问题的解决方案超出了本书的范围，但许多解决这些生物学问题的方法都运用了本文中所介绍的理念，使科学家能够高效地利用资源完成任务。动态规划（如第 14 章所述）是解决其中一些生物学问题的重要技术，特别是那些涉及确定 DNA 序列相似性的问题。所实现的节省体现在时间方面（包括人力和机器时间）以及资金方面，因为通过实验室技术可以提取更多的信息。
- 互联网使世界各地的人们能够迅速获取和检索大量信息。借助巧妙的算法，互联网上的网站能够管理和处理如此庞大的数据量。算法在诸多问题中的应用实例包括：找到数据传输的最佳路径（解决此类问题的技术在第 22 章中有介绍），以及使用搜索引擎快速找到包含特定信息的页面（相关技术在第 11 章和第 32 章中有阐述）。
- 电子商务使得商品和服务能够以电子方式进行协商和交换，并且它依赖于诸如信用卡号码、密码和银行对账单等个人信息的隐私保护。电子商务所使用的核心技术包括公钥加密和数字签名（在第 31 章中有详细介绍），这些技术基于数值算法和数论。
- 制造业及其他商业企业常常需要以最有利的方式分配稀缺资源。例如，一家石油公司可能希望知道如何将油井布局在何处，以实现预期的最大收益。一位政治候选人可能想要确定在哪里投入资金来购买竞选广告，以最大程度地提高赢得选举的机会。一家航空公司可能希望以尽可能低的成本安排机组人员到各个航班上工作，同时确保每个航班都有人覆盖，并且符合有关机组人员排班的规定。一家互联网服务提供商可能希望确定在哪里投入额外资源，以便更有效地为客户提供服务。所有这些都是可以通过将其建模为线性规划问题来解决的例子，第 29 章将对此进行探讨。

虽然这些示例中的某些细节超出了本书的讨论范围，但我们确实会介绍适用于这些问题和相关领域的基本方法。我们还会展示如何解决许多具体问题，包括以下这些：

- 你有一张路线图，上面标注了每对相邻交叉口之间的距离，你想确定从一个交叉口到另一个交叉口的最短路线。即使不允许自相交的路线，可能的路线数量也可能是巨大的。你如何从所有可能的路线中选择最短的那条？你可以先将路线图（它本身是实际道路的模型）建模为图（我们将在第六部分和附录 B 中介绍）。在这个图中，你想找到从一个顶点到另一个顶点的最短路径。第 22 章展示了如何有效地解决这个问题。
- 假设有一个基于零件库的机械设计，其中每个零件都可能包含其他零件的实例。请按照以下方式列出这些零件：确保每个零件都排在使用它的零件之前。如果该设计包含 *n* 个零件，那么就有 *n*! 种可能的排列顺序，其中 *n*! 表示阶乘函数。由于阶乘函数的增长速度甚至比指数函数还要快，所以除非零件数量很少，否则无法切实生成每一种可能的顺序并验证在该顺序中每个零件是否都排在使用它的零件之前。这个问题就是拓扑排序的一个实例，第 20 章将展示如何高效地解决这个问题。
- 医生需要确定一个图像是否代表恶性肿瘤或良性肿瘤。医生可以获得许多其他肿瘤的图像，其中一些已知是恶性的，一些已知是良性的。恶性肿瘤可能与其他恶性肿瘤更相似，而不是与良性肿瘤相似，良性肿瘤更可能与其他良性肿瘤相似。通过使用聚类算法（如第 33 章所述），医生可以确定哪个结果更可能。
- 为了减小大文本文件的体积，我们可以使用多种压缩技术。除了通过识别重复序列进行压缩的 LZW 算法外，第 15 章还将介绍 Huffman 编码。后者的核心逻辑是：根据字符出现频率分配变长编码，频率越高，编码越短

这些列表远非详尽（正如你可能再次从本书的厚度推测出的那样），但它们展示了众多有趣的算法问题共有的两个特征：

- 它们有许多候选解决方案，但其中绝大多数都无法解决当前的问题。在不逐一详细考察每个可能解决方案的情况下，找出一个能解决问题的方案，或者一个“最佳”方案，可能会颇具挑战性。
- 它们具有实际应用价值。在上述列表中的问题中，寻找最短路径是最简单的例子。例如，一家运输公司，比如货运公司或铁路公司，会出于经济利益考虑去寻找通过道路或铁路网络的最短路径，因为走较短的路径能降低劳动力和燃料成本。或者互联网中的一个路由节点可能需要找到通过网络的最短路径，以便快速传输信息。或者一个想要从纽约开车前往波士顿的人可能会想使用导航应用程序来寻找驾车路线。

并非由算法解决的所有问题都能有明确的候选解决方案可供识别。例如，给定一组代表以固定时间间隔采集的信号样本的数值，离散傅里叶变换会将时域转换为频域。也就是说，它将信号近似为一系列正弦波的加权和，从而得出各种频率的强度，这些强度相加后能近似表示所采集的信号。除了是信号处理的核心之外，离散傅里叶变换还应用于数据压缩以及对大多项式和整数的乘法运算。第 30 章给出了一个高效的算法——快速傅里叶变换（通常称为 FFT），用于解决这个问题。该章节还简要介绍了一个硬件 FFT 电路的设计。

### 数据结构

这本书还介绍了几种**数据结构**。数据结构是一种用于存储和组织数据的方式，以便于访问和修改。选择合适的数据结构或多种数据结构是算法设计中非常重要的一部分。没有一种数据结构能适用于所有情况，因此您应该了解它们各自的优点和局限性。

### 技术

虽然你可以把这本书当作算法的手册来使用，但有些时候你可能会遇到一些问题，无法轻松找到已发表的算法（这本书中许多练习和问题就是例子）。本书将教你算法设计和分析的技巧，使你能够自主开发算法，证明它们给出正确答案，并分析其效率。不同的章节涉及算法问题求解的不同方面。有些章节针对特定问题，例如第 9 章中寻找中位数和顺序统计量、第 21 章中计算最小生成树以及第 24 章中确定网络中的最大流。其他章节介绍各种技术，例如第 2 章和第 4 章中的分治法、第 14 章中的动态规划以及第 16 章中的摊销分析。

### 困难问题

本书的大部分内容都涉及高效的算法。我们通常衡量算法的效率的标准是速度：一个算法需要多长时间才能得出结果。然而，也有一些问题，我们目前还没有找到能在合理时间内运行的算法来解决它们。例如第 34 章研究了这类问题中一个有趣的子集，这些问题是被称为“NP 完全问题”的。

为什么 NP 完全问题如此引人关注呢？首先，尽管尚未找到任何针对 NP 完全问题的高效算法，但也没有人能证明不存在这样的高效算法。换句话说，人们并不清楚是否存在针对 NP 完全问题的高效算法。其次，NP 完全问题的集合具有一个非凡的特性：如果针对其中任何一个问题存在高效算法，那么针对所有这些问题都存在高效算法。这种 NP 完全问题之间的关系使得缺乏高效解决方案的状况显得更加令人向往。最后，一些 NP 完全问题与我们已知存在高效算法的问题相似，但又不完全相同。计算机科学家对一个问题陈述的微小变化如何导致已知最佳算法效率的巨大变化而感到好奇。

你应当了解NP完全问题，因为它们在实际应用中时常出人意料地出现。若有人要求你为NP完全问题设计高效算法，你很可能会徒劳耗费大量时间。反之，若能证明该问题是NP完全的，你便可将精力用于开发高效的近似算法——这种算法能提供良好但不一定最优的解决方案。

以一个具体例子来说明：假设某快递公司设有中央仓库。每天，卡车在仓库装载货物后前往多个地址配送，日终时必须返回仓库以便次日继续使用。为降低成本，公司需要为每辆卡车规划出总行驶距离最短的配送路线顺序。这就是著名的"旅行商问题"，属于NP完全问题，目前尚无已知高效算法。但在特定条件下，我们已掌握能计算出接近最短总距离的高效算法。第35章将探讨这类"近似算法"。

### 替代计算模型

多年来，我们一直可以依赖处理器时钟速度以稳定的速率提升。然而，物理限制为时钟速度的持续增长带来了根本性障碍：由于功率密度随时钟速度呈超线性增长，一旦时钟速度达到足够高的水平，芯片便面临熔毁的风险。因此，为了每秒执行更多计算，芯片设计正朝着包含不止一个而是多个处理“核心”的方向发展。我们可以将这些多核计算机比作单芯片上的多个顺序计算机。换言之，它们属于一种“并行计算机”。为了从多核计算机中获取最佳性能，我们需要在设计算法时充分考虑并行性。第26章介绍了一种“任务并行”算法模型，该模型能够充分利用多个处理核心。这一模型在理论和实践层面均具优势，许多现代并行编程平台都采用了与此类似的并行模型。

本书中的大多数示例都假设算法开始运行时所有输入数据都已就绪。算法设计中的大部分工作也基于同样的假设。然而，对于许多重要的现实场景，输入实际上是随时间逐步到达的，算法必须在不知道未来数据的情况下决定如何推进。在数据中心，任务不断到达和离开，调度算法必须在不知道未来任务的情况下决定何时何地运行任务。互联网中的流量必须基于当前状态进行路由，而无法预知未来流量的到达情况。医院急诊室需要根据分诊决策确定优先治疗哪些患者，却无法预知未来何时会有其他患者到达以及他们需要何种治疗。这类随时间逐步接收输入而非在开始时即拥有全部输入的算法被称为在线算法，第27章将对此进行探讨。

### 练习 (Exercises)

**1.1-1**
请举出一个现实生活中需要进行排序的例子。再举出一个需要计算两点间最短距离的例子。

**1.1-2**
在现实场景中，除了速度之外，还有哪些衡量效率的指标是需要考虑的？

**1.1-3**
选择一种你见过的数结构，并讨论它的优点和局限性。

**1.1-4**
前文提到的最短路径问题和旅行商问题有何相似之处？又有何不同？

**1.1-5**
举出一个只有最优解才可行的现实问题。然后再举出一个只需“近似”最优解就足够的例子。

**1.1-6**
描述一个现实问题，其中有时需要在获得全部输入后才能解决，而有时输入则是随着时间推移陆续到达的。

---

## 1.2 作为一种技术的算法

如果计算机的速度无限快，计算机内存也是免费的，你还有理由学习算法吗？答案是有的，至少你仍然希望确保你的求解方法能够终止，并给出正确的答案。

如果计算机的速度无限快，任何能够正确求解问题的方法都可以。你可能希望你的实现遵循良好的软件工程实践（例如，你的实现应该精心设计和文档完整），但你通常会选择最容易实现的方法。

当然，计算机可能速度很快，但不是无限快。因此计算时间是一种有限的资源，这使它非常珍贵。虽然有句谚语说"时间就是金钱"，但时间比金钱更加宝贵：花掉的钱可以再赚回来，但花掉的时间一旦消逝，就永远无法找回。内存可能很便宜，但它既不是无限的，也不是免费的。你应该选择能够有效利用时间和空间资源的算法。

### 效率

为解决同一个问题而设计的不同算法，其效率往往存在显著差异。这种差异通常比硬件性能或软件优化带来的差异影响更为深远。

例如，第 2 章介绍了两种排序算法。第一种被称为**插入排序**（**insertion sort**），对 *n* 个元素进行排序所需的时间大约等于 *c*₁*n*²，其中 *c*₁ 是一个不依赖于 *n* 的常数。也就是说，它消耗的时间大致与 *n*² 成正比。第二种是**归并排序**（**merge sort**），其消耗的时间大约等于 *c*₂*n* lg *n*，这里 lg *n* 代表 log₂ *n*，而 *c*₂ 是另一个同样不依赖于 *n* 的常数。插入排序的常数因子通常比归并排序小，即 *c*₁ < *c*₂。我们将看到，常数因子对运行时间的影响，远不及运行时间对输入规模 *n* 的依赖性所带来的影响。

我们将插入排序的运行时间写为 *c*₁*n* · *n*，将归并排序的运行时间写为 *c*₂*n* · lg *n*。由此可见，在运行时间中，插入排序包含一个因子 *n*，而归并排序包含一个因子 lg *n*，后者要小得多。例如，当 *n* 为 1000 时，lg *n* 约为 10；而当 *n* 为 1,000,000 时，lg *n* 仅约为 20。尽管对于小规模输入，插入排序通常比归并排序运行得更快，但一旦输入规模 *n* 变得足够大，归并排序中 lg *n* 相对于 *n* 的优势，将足以弥补常数因子之间的差距。无论 *c*₁ 比 *c*₂ 小多少，总会存在一个交叉点（crossover point），一旦超过这个点，归并排序就会表现得更快。

为了举一个具体的例子，让我们让一台运行**插入排序**（**insertion sort**）的快速计算机（计算机 *A*）与一台运行**归并排序**（**merge sort**）的慢速计算机（计算机 *B*）进行竞赛。它们都必须对 10,000,000（1000 万）个数字进行排序。（虽然 1000 万个数字看起来很多，但如果这些数字是 8 字节整数，那么输入大约占用 80 MB，这甚至在廉价的笔记本电脑内存中也能容纳好几倍。）假设计算机 *A* 每秒执行 10,000,000,000（100 亿）条指令（在本书写作时，这比任何单台顺序计算机都快），而计算机 *B* 每秒仅执行 10,000,000（1000 万）条指令（比大多数当代计算机慢得多），因此计算机 *A* 在原始计算能力上比计算机 *B* 快 1000 倍。

为了使差异更加剧烈，假设世界上最老练的程序员用机器语言为计算机 *A* 编写了插入排序代码，生成的代码排序 *n* 个数字需要 2*n*² 条指令。进一步假设，一个水平平庸的程序员使用高级语言和低效的编译器实现了归并排序，生成的代码需要 50*n* lg *n* 条指令。为了排序 1000 万个数字，计算机 *A* 需要：

$$\frac{2 \cdot (10^7)^2 \text{ 条指令}}{10^{10} \text{ 条指令/秒}} = 20,000 \text{ 秒}$$

而计算机 *B* 需要：

$$\frac{50 \cdot 10^7 \lg 10^7 \text{ 条指令}}{10^7 \text{ 条指令/秒}} \approx 1163 \text{ 秒}$$

因此，通过使用运行时间增长更慢的算法，即使编译器很差，计算机 *B* 的运行速度也比计算机 *A* 快 17 倍以上！当排序 100,000,000（1 亿）个数字时，归并排序的优势更加明显：插入排序需要超过 23 天，而归并排序不到 4 小时。虽然 1 亿看起来像是一个巨大的数字，但每半小时就有超过 1 亿次网络搜索，每分钟有超过 1 亿封电子邮件被发送，一些最小的星系（称为超致密矮星系）包含大约 1 亿颗恒星。总的来说，随着问题规模的增加，归并排序的相对优势也会随之增加。

### 算法和其他技术

上述例子表明，你应该像对待计算机硬件一样，将算法视为一种**技术**。系统的总体性能既取决于选择高效的算法，也取决于选择快速的硬件。正如其他计算机技术正在飞速发展一样，算法领域也在取得同样迅速的进展。

你可能会想，鉴于其他先进技术的发展，算法在当代计算机上是否真的那么重要？这些技术包括：

- 先进的计算机架构与制造工艺，
- 易于使用且直观的图形用户界面（GUI），
- 面向对象系统，
- 集成的网络技术，
- 有线与无线的快速网络通信，
- 机器学习，
- 以及移动设备。

答案是肯定的。尽管某些应用在应用层并不显式地需要算法内容（例如一些简单的 Web 应用），但许多应用确实需要。例如，考虑一个确定如何从一地旅行到另一地的 Web 服务。它的实现将依赖于快速的硬件、图形用户界面、广域网，可能还依赖于面向对象技术。此外，它还需要用于执行特定操作的算法，如寻找路线（可能使用最短路径算法）、地图渲染以及地址插值。

此外，即使是在应用层不需要算法内容的应用，也严重依赖于算法。该应用依赖于快速硬件吗？硬件设计中就使用了算法。该应用依赖于图形用户界面吗？任何 GUI 的设计都依赖于算法。该应用依赖于网络吗？网络中的路由严重依赖于算法。该应用是用机器码以外的语言编写的吗？那么它就是由编译器、解释器或汇编器处理的，而这些工具都大量使用了算法。在当代计算机使用的绝大多数技术中，算法都处于核心地位。

机器学习可以被视为一种无需显式设计算法即可执行算法任务的方法，它是通过从数据中推断模式，从而自动学习解决方案。乍一看，机器学习自动化了算法设计的过程，似乎会让学习算法变得过时。然而，事实恰恰相反。机器学习本身就是算法的集合，只是换了一个名称而已。此外，目前看来，机器学习的成功主要集中在那些我们人类并不真正理解其“正确算法”为何物的问题上。突出的例子包括计算机视觉和语言自动翻译。对于人类能够很好理解的算法问题（例如本书中的大多数问题），旨在解决特定问题的高效算法通常比机器学习方法更成功。

数据科学是一个跨学科领域，其目标是从结构化和非结构化数据中提取知识和见解。数据科学使用了来自统计学、计算机科学和优化理论的方法。算法的设计与分析是该领域的基础。数据科学的核心技术与机器学习的技术有显著重叠，其中包括本书中的许多算法。

此外，随着计算机处理能力的不断增强，我们正在使用它们来解决比以往任何时候都更宏大的问题。正如我们在上文插入排序和归并排序的对比中所看到的，正是在处理大规模问题时，算法之间的效率差异才变得尤为突出。

拥有扎实的算法知识和技术基础，是定义一名真正优秀程序员的特征之一。在现代计算技术的帮助下，即使不了解太多算法，你也能完成某些任务；但如果具备良好的算法背景，你就能做得更多、更好。

### 习题

**1.2-1**
举出一个在应用层需要算法内容的应用程序例子，并讨论其中涉及算法的功能。

**1.2-2**
假设在某台特定的计算机上，对于规模为 *n* 的输入，插入排序运行 8*n*² 步，而归并排序运行 64*n* lg *n* 步。对于哪些 *n* 值，插入排序会优于归并排序？

**1.2-3**
在同一台机器上，运行时间为 100*n*² 的算法比运行时间为 2ⁿ 的算法运行得更快，满足这一条件的 *n* 的最小值是多少？

---

### 思考题

**1-1 运行时间的比较**
对于下表中的每一个函数 *f*(*n*) 和时间 *t*，确定在时间 *t* 内能解决的问题的最大规模 *n*。假设解决该问题的算法需要 *f*(*n*) 微秒（μ*s*）。

| | 1 秒 | 1 分钟 | 1 小时 | 1 天 | 1 月 | 1 年 | 1 世纪 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| lg *n* | | | | | | | |
| √*n* | | | | | | | |
| *n* | | | | | | | |
| *n* lg *n* | | | | | | | |
| *n*² | | | | | | | |
| *n*³ | | | | | | | |
| 2ⁿ | | | | | | | |
| *n*! | | | | | | | |

---

### 本章注记

关于算法这一通用主题，有许多优秀的教材，包括 Aho、Hopcroft 和 Ullman [5, 6]，Dasgupta、Papadimitriou 和 Vazirani [107]，Edmonds [133]，Erickson [135]，Goodrich 和 Tamassia [195, 196]，Kleinberg 和 Tardos [257]，Knuth [259, 260, 261, 262, 263]，Levitin [298]，Louridas [305]，Mehlhorn 和 Sanders [325]，Mitzenmacher 和 Upfal [331]，Neapolitan [342]，Roughgarden [385, 386, 387, 388]，Sanders、Mehlhorn、Dietzfelbinger 和 Dementiev [393]，Sedgewick 和 Wayne [402]，Skiena [414]，Soltys-Kulinicz [419]，Wilf [455]，以及 Williamson 和 Shmoys [459] 的著作。

算法设计中一些偏重实践方面的探讨可见于 Bentley [49, 50, 51]、Bhargava [54]、Kochenderfer 和 Wheeler [268] 以及 McGeoch [321] 的作品。关于算法领域的综述也可以在 Atallah 和 Blanton [27, 28] 以及 Mehta 和 Sahni [326] 的书中找到。若想阅读技术性稍弱的材料，请参阅 Christian 和 Griffiths [92]、Cormen [104]、Erwig [136]、MacCormick [307] 以及 Vöcking 等人 [448] 的著作。计算生物学中所用算法的概览可以在 Jones 和 Pevzner [240]、Elloumi 和 Zomaya [134] 以及 Marchisio [315] 的书中找到。
